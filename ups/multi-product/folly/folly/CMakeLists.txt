include(ExternalProject)

# We could just set the CMAKE_INSTALL_*DIR directories directly to
# ${CMAKE_INSTALL_PREFIX}/${folly_*_dir}, but we want to
# use CPack, which only knows about files/directories that are
# install()ed. So we install into a staging area and then install()
# from the staging area into the final destination
ExternalProject_Add (
  folly

  PREFIX         folly
  GIT_REPOSITORY https://github.com/facebook/folly
  GIT_TAG        v2020.05.25.00
  GIT_SHALLOW    ON

  BUILD_ALWAYS   OFF
  INSTALL_DIR    ${PROJECT_BINARY_DIR}/external_staging
  CMAKE_ARGS     -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR>
                 -DLIB_INSTALL_DIR:PATH=${folly_lib_dir}
                 -DBIN_INSTALL_DIR:PATH=${folly_bin_dir}
                 -DINCLUDE_INSTALL_DIR:PATH=${folly_inc_dir}
                 -DBUILD_SHARED_LIBS=on
                 # -DCMAKE_POLICY_DEFAULT_CMP0074=NEW # Needed for <Package>_ROOT variables to work
                 # -DBoost_NO_BOOST_CMAKE=on -DBOOST_ROOT=$ENV{BOOST_FQ_DIR}
                 # -DDoubleConversion_ROOT=$ENV{DOUBLE_CONVERSION_LIB} # ups-specific hint for find_package
                 # -DDOUBLE_CONVERSION_INCLUDE_DIR=$ENV{DOUBLE_CONVERSION_INC}
                 # -DFmt_ROOT=$ENV{FMT_LIB} # ""
                 # -DFMT_INCLUDE_DIR=$ENV{FMT_INC} # ""
                 # -DGlog_ROOT=$ENV{GLOG_LIB}
                 # -DGLOG_INCLUDE_DIR=$ENV{GLOG_INC}
                 # -DLibEvent_ROOT=$ENV{LIBEVENT_LIB}
                 -DCMAKE_POSITION_INDEPENDENT_CODE=on
)

# The trailing / on the DIRECTORY argument acts like it does for
# cp. We need it to avoid double directories in the output. We have to
# use relative paths for the DESTINATION (which are interpreted as
# being relative to ${CMAKE_INSTALL_PREFIX}), so that CPack will work
message(STATUS "Going to install ${PROJECT_BINARY_DIR}/external_staging to ${CMAKE_INSTALL_PREFIX}")
install(DIRECTORY ${PROJECT_BINARY_DIR}/external_staging/${folly_lib_dir}/
       DESTINATION ${folly_lib_dir})
install(DIRECTORY ${PROJECT_BINARY_DIR}/external_staging/${folly_inc_dir}/
       DESTINATION ${folly_inc_dir})
# The folly-targets.cmake file is generated by the inner cmake (ie, the
# one from folly itself), and contains all the necessary definitions
# that allow other packages to link against/include folly via `folly::folly`
# and similar. We can't generate it ourselves because it's
# autogenerated by cmake based on the targets that are declared in the
# cmake files. We have to copy it because ups puts installed cmake
# files in a non-standard place
install(FILES ${PROJECT_BINARY_DIR}/external_staging/${folly_lib_dir}/cmake/folly/folly-targets.cmake
        DESTINATION ${folly_lib_dir}/folly/cmake/)
